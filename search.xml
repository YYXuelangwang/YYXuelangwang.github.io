<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>blog add comment plug-in</title>
    <url>/2020/04/30/blog_comment/</url>
    <content><![CDATA[<p>写这篇文章的目的旨在，记录自己是如何给自己的hexo博客添加comment的，希望能给到你一些帮助</p>
<ol>
<li><p>comment插件</p>
<p> 当你使用一种主题的时候，你可以打开对应主题文件目录中的<label style="color:#b77a64">_config.yml</label>文件，你可以看到很多对应的功能或说明；<br> 我这里使用的主题是<label style="color:#b77a64">next</label>，对应的文件目录结构是<code>themes/next/_config.yml</code></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Valine.</span><br><span class="line"># You can get your appid and appkey from https://leancloud.cn</span><br><span class="line"># more info please open https://valine.js.org</span><br><span class="line">valine:</span><br><span class="line">  enable: false</span><br><span class="line">  appid:  # your leancloud application appid</span><br><span class="line">  appkey: # your leancloud application appkey</span><br><span class="line">  notify: true # mail notifier , https://github.com/xCss/Valine/wiki</span><br><span class="line">  verify: false # Verification code</span><br><span class="line">  placeholder: Just go go # comment box placeholder</span><br><span class="line">  avatar: mm # gravatar style</span><br><span class="line">  guest_info: nick,mail,link # custom comment header</span><br><span class="line">  pageSize: 10 # pagination size</span><br></pre></td></tr></table></figure>

<p> 上面你看到的就是next主题支持的comment插件valine；你也可以搜索你的主题可以支持的comment插件；</p>
</li>
<li><p><a href="https://valine.js.org/" target="_blank" rel="noopener">valine</a></p>
<p> 是一款基于LeanCloud的快速、简洁且高效的无后端评论系统。<br> valine评论功能是依赖<a href="https://www.leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a>的，需要你在leanCloud注册一个自己的产品，拿到对应的appid和appkey；</p>
<ol>
<li><p>配置leanCloud</p>
<p> 在你创建好自己的产品后，（[如何创建自己的产品])，配置邮件模板路径<em><code>设置 =&gt; 邮件模板</code></em>，将其中用于重置密码的邮件主题更改内容（这是因为Valine官方提供的邮件提醒功能是基于Leancloud的密码重置邮件提醒）</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;Hi, &#123;&#123;username&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">你在 &#123;&#123;appname&#125;&#125; 的评论收到了新的回复，请点击查看：</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;a href=&quot;你的网址首页链接&quot; style=&quot;display: inline-block; padding: 10px 20px; border-radius: 4px; background-color: #3090e4; color: #fff; text-decoration: none;&quot;&gt;马上查看&lt;/a&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p> 上面代码中记得将<label style="color:#b77a64">“你的网址首页链接”</label>更换为自己的博客地址</p>
</li>
<li><p>修改_config.yml文件配置信息</p>
<p> 修改next主题中对应的key-value，就是上面提到的_config.yml文件，将appid,appkey替换为你在leancloud中对应产品的appid,appkey(路径：设置 =&gt; 应用key)，enable设置为true</p>
<p> 至此，你就可以看到评论系统了，尝试评论后，在leanCloud网站上查看自己应用的数据库消息，你将看到评论信息（路径：存储 =&gt; 结构化数据 =&gt; Comment)</p>
</li>
<li><p><a href="https://github.com/zhaojun1998/Valine-Admin" target="_blank" rel="noopener">Valine-Admin</a>实现邮件提醒功能</p>
<p> 进入<a href="https://www.leancloud.cn/" target="_blank" rel="noopener">leancloud</a>中，自己应用目录下，点击云引擎 =&gt; 设置，填写valine-admin的代码库并保存<code>https://github.com/zhaojun1998/Valine-Admin</code></p>
<p> 切换到部署标签，（路径：云引擎 =&gt; 部署），分支选择master，点击部署</p>
<p> 设置云引擎的环境变量，（记得在保存后，需要重启云引擎，路径：云引擎 =&gt; 部署）</p>
<ul>
<li><p>SITE_NAME : 网站名称。</p>
</li>
<li><p>SITE_URL : 网站地址, 最后不要加 / 。</p>
</li>
<li><p>SMTP_USER : SMTP 服务用户名，一般为邮箱地址。</p>
</li>
<li><p>SMTP_PASS : SMTP 密码，一般为授权码，而不是邮箱的登陆密码，请自行查询对应邮件服务商的获取方式</p>
</li>
<li><p>SMTP_SERVICE : 邮件服务提供商，支持 QQ、163、126、Gmail、”Yahoo”、…… ，全部支持请参考 : <a href="https://nodemailer.com/smtp/well-known/#supported-services" target="_blank" rel="noopener">Nodemailer Supported services</a>。 — 如这里没有你使用的邮件提供商，请查看<a href="https://www.nhtzj.com/%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE.md#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">自定义邮件服务器</a></p>
</li>
<li><p>SENDER_NAME : 寄件人名称。</p>
<p>如果这里你需要使用到自己的邮箱，或者SMTP_SERVICE中不支持，那么你需要额外设置以下三个环境变量，否则不用哈</p>
</li>
<li><p>SMTP_HOST : 邮件服务提供商 SMTP 地址，如 qq : smtp.qq.com，此项需要自行查询或询问其服务商。</p>
</li>
<li><p>SMTP_PORT : 邮件服务提供商 SMTP 端口, 此项需要自行查询或询问其服务商。</p>
</li>
<li><p>SMTP_SECURE : 是否启用加密, 默认为 true，一般不需要设置，如有特殊请自行配置。 此项需要自行查询或询问其服务商。</p>
<p>额外的两个参数，可加可不加</p>
</li>
<li><p>TO_EMAIL：这个是填收邮件提醒的邮箱地址，若没有这个字段，则将邮件发到SMTP_USER。</p>
</li>
<li><p>TEMPLATE_NAME：设置提醒邮件的主题，目前内置了两款主题，分别为 default 与 rainbow。默认为 default 。</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>注：</p>
<ol>
<li><p>因为免费版的LeanCloud容器，是有强制性休眠策略的，不能24小时运行；每天必须休眠6个小时；30分钟内没有外部请求，则休眠；休眠后如果有新的外部请求实例则马上启动（但激活时此次发送邮件会失败）；所以，如果你要解决此问题，可参考<a href="https://github.com/zhaojun1998/Valine-Admin/blob/master/%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE.md#%E5%BC%80%E5%8F%91" target="_blank" rel="noopener">Valine-Admin配置LeanCloud休眠策略</a></p>
</li>
<li><p>关于SMTP_PASS，SMTP密码，SMTP授权码，如何获取，可以参看<a href="https://service.mail.qq.com/cgi-bin/help?subtype=1&id=28&no=1001256" target="_blank" rel="noopener">SMTP授权码</a></p>
</li>
</ol>
<p>因为是根据大神博客来操作的，所以很多图片说明在大神文章中都有，在此就不再添加了<br>文献参考：<br>    * <a href="https://www.nhtzj.com/3315416634/" target="_blank" rel="noopener">NexT主题设置Valine评论系统邮件提醒</a><br>    * <a href="https://github.com/zhaojun1998/Valine-Admin" target="_blank" rel="noopener">Valine-Admin仓库地址</a><br>    * <a href="https://github.com/zhaojun1998/Valine-Admin/blob/master/%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE.md#%E5%BC%80%E5%8F%91" target="_blank" rel="noopener">Valine-Admin配置LeanCloud休眠策略</a></p>
]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>first stage hexo</title>
    <url>/2019/06/17/first-stage-hexo/</url>
    <content><![CDATA[<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ol>
<li><code>$ hexo init [folder]</code> 新建一个网站</li>
<li><code>$ hexo new [layout] &lt;title&gt;</code>  新建一篇文章</li>
<li><code>$ hexo generate</code> 生成静态文件</li>
<li><code>$ hexo server</code> 启动服务器</li>
<li><code>$ hexo deploy</code> 部署网站</li>
<li><code>$ hexo clean</code> 清除缓存(db.json 和 public中的静态文件)</li>
<li><code>$ hexo list &lt;type&gt;</code> 列出网站资料</li>
</ol>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>app性能分析</title>
    <url>/2019/06/19/app%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h4 id="app性能分析图"><a href="#app性能分析图" class="headerlink" title="app性能分析图"></a>app性能分析图</h4><ul>
<li>app通过调用<em>CPU</em>来计算；</li>
<li>app通过<em>MEM</em>来读取/存储数据；</li>
<li>app通过<em>NET</em>来请求数据通信；</li>
</ul>
<p>检测的话，一般都是围绕上面三点来展开的；大部分的编辑器都有着profile/memory工具来进行检测；使用profile可以定位到哪些方法占用cpu资源多，占用的时间长；使用memory则可以来检测到不同的object引用计数，和占用内存的大小；同样，network也有对应的检测工具，network的优化可以通过减少请求次数（合并请求次数），和压缩请求的数据(例如gzip)；</p>
]]></content>
      <tags>
        <tag>app</tag>
      </tags>
  </entry>
  <entry>
    <title>git increase</title>
    <url>/2020/04/24/git_increase/</url>
    <content><![CDATA[<p>写这篇文章的目的是为了缓存自己在git上的提示/升级路程，在平时使用过程的记录等；在文章不断增长的过程中，会把部分内容提取出来单独作为一个新的篇章记录说明；</p>
<h4 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h4><p>缓存处处理，当自己有调试代码穿插在项目中时，而这时由于自己或项目其他的人的观念不一致，不允许自己将调试代码上传到仓库时；当当当，你就可以使用这个来管理了，so easy</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usage: git stash list [&lt;options&gt;]</span><br><span class="line">   or: git stash show [&lt;stash&gt;]</span><br><span class="line">   or: git stash drop [-q|--quiet] [&lt;stash&gt;]</span><br><span class="line">   or: git stash ( pop | apply ) [--index] [-q|--quiet] [&lt;stash&gt;]</span><br><span class="line">   or: git stash branch &lt;branchname&gt; [&lt;stash&gt;]</span><br><span class="line">   or: git stash save [--patch] [-k|--[no-]keep-index] [-q|--quiet]</span><br><span class="line">		      [-u|--include-untracked] [-a|--all] [&lt;message&gt;]</span><br><span class="line">   or: git stash [push [--patch] [-k|--[no-]keep-index] [-q|--quiet]</span><br><span class="line">		       [-u|--include-untracked] [-a|--all] [-m &lt;message&gt;]</span><br><span class="line">		       [-- &lt;pathspec&gt;...]]</span><br><span class="line">   or: git stash clear</span><br></pre></td></tr></table></figure>

<p>那上面就是他的一些用法了，我就拿几个叨叨</p>
<ol>
<li><p><label style="color:#b77a64">git stash [message]</label></p>
<p>等同于<code>git stash save</code>创建缓存，message是你缓存的说明；</p>
</li>
<li><p><label style="color:#b77a64">git stash list</label></p>
<p>查看缓存列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stash@&#123;0&#125;: On release.1100:xxx</span><br></pre></td></tr></table></figure>
</li>
<li><p><label style="color:#b77a64">git stash pop stash@{num}</label></p>
<p>应用缓存后将缓存删除，有点类似栈的操作，num代表你要操作的缓存序列号</p>
</li>
<li><p><label style="color:#b77a64">git stash drop stash@{num}</label></p>
<p>删除缓存</p>
</li>
<li><p><label style="color:#b77a64">git stash apply stash@{num}</label></p>
<p>应用缓存，但是不会删除缓存</p>
</li>
</ol>
<h4 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h4><p>给自己的分支打tag/标签，</p>
<ol>
<li><p><label style="color:#b77a64">git tag</label></p>
<p>罗列出来已经创建的tag</p>
</li>
<li><p><label style="color:#b77a64">git tag -a [xxx] -m [message]</label></p>
<p>创建tag，<em>xxx</em>代表tag的值，版本号啊啥的，<em>message</em>代表说明</p>
</li>
<li><p><label style="color:#b77a64">git push origin [xxx]</label></p>
<p>推送指定的tag到远程仓库</p>
</li>
<li><p><label style="color:#b77a64">git tag -d [xxx]</label></p>
<p>删除指定的tag分支</p>
</li>
<li><p><label style="color:#b77a64">git push origin –delete [xxx]</label></p>
<p>删除远程仓库的标签/tag</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2019/06/21/ios%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<p>IOS安全是我看书的一些笔记；</p>
<p>####第2章</p>
<p>#####关键的几个类库</p>
<p>Cocoa    :    部分框架和Objective-c gui编程APi的总称</p>
<p>Cocoa Touch    :    Cocoa的一个超集</p>
<p>Core Foundation    :    基于C的类库</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/06/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>ios简介</title>
    <url>/2019/10/23/ios%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B51/</url>
    <content><![CDATA[<h4 id="IOS简介"><a href="#IOS简介" class="headerlink" title="IOS简介"></a>IOS简介</h4><p>#####ios平台的特殊性</p>
<p>开发者账号有四种类型：个人账号和公司账号为99美元/年，企业账号是299美元/年，教育账号是0美元/年；</p>
<p>#####证书类型</p>
<table>
<thead>
<tr>
<th>证书名称</th>
<th>AppStore</th>
<th>Adhoc</th>
<th>In House</th>
</tr>
</thead>
<tbody><tr>
<td>安装范围</td>
<td>只能通过AppStore安装</td>
<td>设置UDID添加到证书才可以安装，一年限定100台</td>
<td>任何ios设置均可以安装</td>
</tr>
<tr>
<td>开发者类型</td>
<td>个人/公司/教育账号</td>
<td>个人/公司/企业/教育账号</td>
<td>企业账号</td>
</tr>
</tbody></table>
<p>In House ：企业签名方式，可以不通过AppStore下载，也不限定安装的设备数。但苹果公司严禁企业签名的包流入用户手中，只允许公司内部小范围内安装体验，一旦发现违规，就会做永久下架处理；</p>
<h5 id="越狱"><a href="#越狱" class="headerlink" title="越狱"></a>越狱</h5><p>就是获取ios设备的root权限；越狱后，可以用到，如测试性能用到的远程连接工具openssh、用于录屏的display recorder，以及启动app和抓取数据包等操作要用到的命令行工具等；</p>
<h5 id="灰度"><a href="#灰度" class="headerlink" title="灰度"></a>灰度</h5><p>产品在正式发布之前，都会发布一个beta灰度版本，也就是对所有用户公开的测试版本，又称公测；可以说，灰度版本是软件生命周期的必经阶段；虽然在ios8上，苹果提供了一种新的灰度渠道，将TestFlight整合进了iTunes Connect，开发人员可以通过电子邮件邀请用户通过TestFlight下载应用一起来参与测试。要用TestFlight有以下几个条件；</p>
<ol>
<li>开发者自己收集总数不超过2000个的邮箱账号提交TestFlight.</li>
<li>提交的App版本要审核三天；</li>
<li>用户需要下载TestFlight客户端到手机，登录自己的Apple ID并填写邮件里的邀请码；</li>
<li>一个邀请码只能在一个Apple ID使用；</li>
<li>第二次发布体验版的时候，用户需要手工去TestFlight里面点击更新；</li>
</ol>
<p>实际上遇到的问题还有：</p>
<ol>
<li>通过各种论坛收集的用户邮箱账号提交后，有三分之一的用户收不到邀请码；</li>
<li>剩下三分之二的用户里又有二分之一的用户不会去下载灰度体验版本；</li>
<li>仅剩的下载了体验版本的用户使用不活跃，也没有什么反馈提交；</li>
<li>反馈的信息不足，联系用户困难，基本联系不上，复现问题的概率很低；</li>
</ol>
<p>建议：可以采用企鹅众测（tesly.qq.com）作为灰度发布的主要渠道，企鹅众测又称为Tesly；通过这种方式可以有效调起TestFlight上灰度版本的下载和体验率，获取项目组需要的质量信息；</p>
<h5 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h5><p>ios平台上自动化测试工具比较少，虽然ios平台的自动化测试工具有UITest、XCTest、KIF、Cabalsh、Appium等，但距离运用到每日迭代持续集成还有很长的距离；</p>
<ol>
<li>框架稳定性不高；随着用例数的增多，框架可能要连续运行多个小时，这时大部分框架就会暴露出稳定性不高的问题，频繁出现闪退，只能重新启动项目，增加了人为干预的时间，目前只有XCTest在这方面比较有优势。</li>
<li>无法获取底层接口；由于ios系统的封闭性，导致无法获取系统root权限和系统状态等，给自动化的运行带来了难处；</li>
<li>无自动分析运行结果的日志系统；脚本运行不是目的，最重要的是要看到运行的结果，对异常问题能够快速定位问题。</li>
</ol>
]]></content>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title>shell increase</title>
    <url>/2020/04/26/shell_increase/</url>
    <content><![CDATA[<p>写这篇文章的目的是为了收集自己平时在工作中使用到的shell命令或一些方法，方便自己后面追溯，（主要是自己记不住T_T）</p>
<h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p>grep用来过滤文件内容的每一行再好不过了，内部应该也是启用了io的相关操作吧（如果你有兴趣可以研究一下），当然，它可以过滤你在控制台的输出；你可以使用命令<label style="color:#b77a64"><code>man grep</code></label>来查看grep的更多信息，这里列举一些常见用法：</p>
<ol>
<li><p><label style="color:#b77a64">grep [message]</label></p>
<p> 过滤每一行包含<em>message</em>的内容，并输出在控制台里</p>
</li>
<li><p><label style="color:#b77a64">grep ‘reg’</label></p>
<p> 过滤每一行中符合正则表达式的内容，并输出在控制台里；如果你有考虑多个正则表达式，那么你可能会用到下面的命令来执行<label style="color:#b77a64"><code>grep -e &#39;regA&#39; -e &#39;regB&#39;</code> </label>（这个命令的意思是’或‘，内容只要符合其中任何一个正则表达式，就会被输出/拿到）、<label style="color:#b77a64"><code>grep &#39;regA&#39; | grep &#39;regB&#39;</code></label>(这个命令的意思是’与‘，相当于执行了两遍grep命令，如果是少数内容（几个文件）还好，多的话（上万个文件）还得找下grep对应的指令集了)</p>
</li>
<li><p><label style="color:#b77a64">grep -v ‘reg/message’</label></p>
<p> 取反，不包含指定的正则表达式<em>reg</em>或者<em>message</em></p>
</li>
<li><p><label style="color:#b77a64">grep –color ‘message’</label></p>
<p> 给<em>message</em>添加颜色，方便自己阅读</p>
</li>
</ol>
<p>一些组合命令：</p>
<ol>
<li><p><label style="color:#b77a64">find [dir] -name ‘*.txt’ | xargs grep ‘message’&lt;</label>&gt;</p>
<p> 前半段的意思是在<em>dir</em>中找到以后缀以.txt结尾的文件列表，后半段的意思就是过滤出来每个文件中包含message内容的行；grep后的命令你可以参考上面的内容来改动；</p>
</li>
<li><p><label style="color:#b77a64">grep ‘xxx’ | sed -n ‘/2020-04-20 16:00:00/,/2020-04-20 19:00:00/p’ test.log</label></p>
<p> 过滤日志信息，结合sed的使用来过滤某一段时间的信息；</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>blog update</title>
    <url>/2020/04/28/update_blog/</url>
    <content><![CDATA[<p>写这篇文章的目的是为了记录，自己需要改进自己的博客时，能快速找到各位前辈大能的文章，地址</p>
<h4 id="主题Next"><a href="#主题Next" class="headerlink" title="主题Next"></a>主题Next</h4><ol>
<li><a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">github地址</a></li>
<li><a href="https://github.com/theme-next/awesome-next" target="_blank" rel="noopener">相关插件（搜索，评论等）github地址</a></li>
</ol>
<h4 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h4><ol>
<li><a href="https://hexo.io/docs/one-command-deployment" target="_blank" rel="noopener">hexo文档地址</a></li>
<li>给自己的hexo博客添加评论，使用的是minivaline<ol>
<li>要使用minvaline需要现在<a href="https://leancloud.cn/dashboard/app.html?appid=uuE0OYy95m5hobJboOUKcMYo-gzGzoHsz#/key" target="_blank" rel="noopener">leancloud</a>上注册一个应用，拿到对应的appkey和appid<br><a href="https://github.com/MiniValine/hexo-next-minivaline" target="_blank" rel="noopener">Hexo Next MiniValine</a></li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2019/06/22/%E5%9F%9F%E5%90%8D%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>域名解析，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st=&gt;start: Start: www.baidu.com</span><br><span class="line">op1=&gt;operation: 本地路由,</span><br><span class="line">(192.168.0.1:53)dns域名解析缓存拿到ip</span><br><span class="line">cond1=&gt;condition: Yes or No?:</span><br><span class="line">op2=&gt;operation: 网络商，</span><br><span class="line">(222.45.3.1:53)dns域名解析拿到ip</span><br><span class="line">cond2=&gt;condition: Yes or No?:</span><br><span class="line">op3=&gt;operation: 其他网路服务商，</span><br><span class="line">dns域名解析拿到ip...</span><br><span class="line">cond3=&gt;condition: Yes or No?:</span><br><span class="line">op4=&gt;operation: 13台根服务器，</span><br><span class="line">dns域名解析拿到ip</span><br><span class="line">cond4=&gt;condition: Yes or No?:</span><br><span class="line">para=&gt;parallel: 拿到ip,可能和上次不一样，</span><br><span class="line">拥有多个ip(不同dns解析的ip可能不同)</span><br><span class="line">para1=&gt;parallel: 未知域名，无法解析</span><br><span class="line">e=&gt;end: 拿到ip,可能和上次不一样，</span><br><span class="line">拥有多个ip(不同dns解析的ip可能不同)</span><br><span class="line">st-&gt;op1-&gt;cond1</span><br><span class="line">cond1(yes)-&gt;e</span><br><span class="line">cond1(no,b)-&gt;op2-&gt;cond2</span><br><span class="line">cond2(yes)-&gt;e</span><br><span class="line">cond2(no,b)-&gt;op3-&gt;cond3</span><br><span class="line">cond3(yes)-&gt;e</span><br><span class="line">cond3(no,b)-&gt;op4-&gt;cond4</span><br><span class="line">cond4(yes)-&gt;e</span><br><span class="line">cond4(no,b)-&gt;para1</span><br><span class="line">e(path1, bottom)-&gt;cond4(right)</span><br></pre></td></tr></table></figure>

<p>#####dns劫持</p>
<p>网路运行商，有时会根据你的域名来返回他的广告地址ip;</p>
<p>Eg: <code>访问www.baidu.com，运营商会从他的域名解析服务器中给你返回一个广告ip地址，xx.xx.xx.xx</code></p>
<p>早起的gfw就是dns劫持，从域名中判断关键字(eg:google)，包含就返回一个无效ip；现金翻墙，将udp包(dns域名请求解析包)加密，跳过gfw，到达vps；</p>
<p><strong>预防dns劫持</strong></p>
<p>电脑上配置dns服务器，网路-&gt;高级-&gt;DNS</p>
<p>路由器上配置dns服务器；</p>
<h5 id="常用的公共域名解析服务dns"><a href="#常用的公共域名解析服务dns" class="headerlink" title="常用的公共域名解析服务dns"></a>常用的公共域名解析服务dns</h5><ul>
<li>8.8.4.4</li>
<li>8.8.8.8</li>
<li>114.114.114.114</li>
<li>114.114.115.115</li>
<li>223.5.5.5</li>
<li>223.6.6.6</li>
</ul>
<h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><p><em>nslookup</em></p>
<p>查询本地使用的dns；输入server，可以设置域名解析服务dns</p>
<p><em>dig</em></p>
<p>展示递归的dns解析</p>
<h4 id="cdn"><a href="#cdn" class="headerlink" title="cdn"></a>cdn</h4>]]></content>
  </entry>
</search>
